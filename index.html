<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Israel's Game — Computer Science P2 (Deluxe 3D Demo)</title>
  <!-- Three.js + extras (CDN) -->
  <script src="https://unpkg.com/three@0.155.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.155.0/examples/js/controls/PointerLockControls.js"></script>
  <script src="https://unpkg.com/three@0.155.0/examples/js/postprocessing/EffectComposer.js"></script>
  <script src="https://unpkg.com/three@0.155.0/examples/js/postprocessing/RenderPass.js"></script>
  <script src="https://unpkg.com/three@0.155.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

  <style>
    /* --------------------
       Layout + UI styling
       -------------------- */
    html,body{height:100%;margin:0;font-family:Inter, Arial, sans-serif;background:#071225;color:#e8f6ff}
    #root{height:100vh;display:flex;flex-direction:column}
    header{display:flex;justify-content:space-between;align-items:center;padding:12px 18px;background:linear-gradient(180deg,#072034,transparent);box-shadow:0 2px 8px rgba(0,0,0,0.4)}
    h1{margin:0;font-size:18px}
    #controls{display:flex;gap:10px;align-items:center}
    #controls button{background:#1e90ff;border:none;color:white;padding:8px 10px;border-radius:6px;cursor:pointer}
    #controls input[type=range]{width:120px}

    main{flex:1;display:flex;align-items:center;justify-content:center;position:relative}
    #gameCanvas{width:100%;height:100%;display:block;background:#050616}

    /* HUD */
    .hud{position:absolute;left:12px;top:12px;pointer-events:none}
    .panel{background:rgba(6,12,20,0.6);backdrop-filter:blur(6px);padding:8px 10px;border-radius:8px;color:#d7efff}
    .hud .small{font-size:13px;opacity:0.9}
    .hud .large{font-size:24px;font-weight:700}
    .bottom-right{position:absolute;right:12px;bottom:12px}

    /* Menu */
    #menu{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:760px;max-width:96%;z-index:1000}
    #menu .menu-inner{padding:18px}
    .muted{color:#9fb5cf}

    /* Game Over / Overlay */
    #overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none}
    .modal{pointer-events:auto;background:rgba(3,6,12,0.85);padding:18px;border-radius:12px;color:#e7f8ff}
    .grid{display:grid;grid-template-columns:1fr 260px;gap:12px}
    .small{font-size:13px}

    footer{position:fixed;left:12px;bottom:6px;color:#8faecf;font-size:12px}

    /* Responsive tweaks */
    @media (max-width:640px){ header{padding:8px} .grid{grid-template-columns:1fr} }

  </style>
</head>
<body>
  <div id="root">
    <header>
      <h1>Israel's Game — Computer Science P2 (Deluxe 3D Demo)</h1>
      <div id="controls">
        <label class="small muted">Sensitivity <input id="sensitivity" type="range" min="0.2" max="1.8" step="0.05" value="0.95"></label>
        <button id="startBtn">Start</button>
        <button id="pauseBtn">Pause</button>
        <button id="resetBtn">Reset</button>
      </div>
    </header>

    <main>
      <canvas id="gameCanvas"></canvas>

      <!-- HUD -->
      <div class="hud" style="top:12px;left:12px">
        <div class="panel small">Score: <span id="score">0</span> | Health: <span id="health">100</span> | Ammo: <span id="ammo">30</span></div>
      </div>

      <div class="hud bottom-right" style="right:12px;top:12px">
        <div class="panel small">Enemies: <span id="enemiesCount">0</span></div>
      </div>

      <!-- Menu / settings -->
      <div id="menu" class="panel modal" style="display:block">
        <div class="menu-inner">
          <h2 style="margin-top:0">Welcome — Israel's Game</h2>
          <div class="grid">
            <div>
              <p class="muted">This is a detailed single-file 3D demo built with Three.js. It includes:
              <ul>
                <li>First-person pointer-lock controls (WASD, mouse to look)</li>
                <li>Player physics and capsule collision</li>
                <li>Shooting (hitscan + projectile), reloading, ammo, and pickups</li>
                <li>Enemy AI with patrol / seek / attack states</li>
                <li>Particle effects, procedural audio using WebAudio API</li>
                <li>HUD, menus, save high score to localStorage</li>
              </ul>
              </p>
              <p class="small muted">Tip: Click "Start" then click the canvas to lock the mouse and play. Press <strong>R</strong> to respawn, <strong>F</strong> for fullscreen, <strong>Esc</strong> to unlock pointer.</p>
            </div>
            <div>
              <div style="display:flex;flex-direction:column;gap:8px">
                <label class="small">Difficulty<select id="difficultySelect"><option>Easy</option><option selected>Normal</option><option>Hard</option></select></label>
                <label class="small">Music <input type="checkbox" id="musicToggle" checked></label>
                <label class="small">SFX <input type="checkbox" id="sfxToggle" checked></label>
                <label class="small">Pointer Lock<button id="lockBtn">Click to Lock</button></label>
                <div style="display:flex;gap:6px;justify-content:flex-end"><button id="hideMenu">Play</button></div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div id="overlay"></div>
    </main>

    <footer>Made for: Israel Flores — Computer Science P2</footer>
  </div>

  <script>
  /* =====================================================
     Deluxe 3D Shooter — Single-file index.html
     - Heavily commented, modular sections
     - Designed to be readable, extendable, and educational
     ===================================================== */

  // --------- Feature flags & configuration ----------
  const CONFIG = {
    worldSize: { x: 300, z: 800 }, // world extents (x axis right/left, z forward/back)
    gravity: -30,                  // units / sec^2
    player: { speed: 8, jumpSpeed: 7, height:1.8, radius:0.35 },
    bulletSpeed: 120,
    enemy: { count: 8, spawnRadius: 120 },
    maxEnemies: 60,
    debug: false
  };

  // ---------- Basic Three.js setup ------------------
  const canvas = document.getElementById('gameCanvas');
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, powerPreference: 'high-performance' });
  renderer.outputEncoding = THREE.sRGBEncoding;
  renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x071225);
  scene.fog = new THREE.FogExp2(0x071225, 0.0012);

  const camera = new THREE.PerspectiveCamera(75, 16/9, 0.1, 2000);
  camera.position.set(0, CONFIG.player.height, 10);

  // Postprocessing (optional)
  let composer = null;
  try {
    const renderPass = new THREE.RenderPass(scene, camera);
    const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.45, 0.4, 0.85);
    composer = new THREE.EffectComposer(renderer);
    composer.addPass(renderPass);
    composer.addPass(bloomPass);
  } catch(e){ composer = null; }

  // ---------- Resize handling -----------------------
  function resize(){
    const w = canvas.clientWidth || window.innerWidth;
    const h = canvas.clientHeight || window.innerHeight;
    camera.aspect = w/h; camera.updateProjectionMatrix();
    renderer.setSize(w,h,false);
    if(composer) composer.setSize(w,h);
  }
  window.addEventListener('resize', resize); resize();

  // ---------- Lighting ------------------------------
  const hemi = new THREE.HemisphereLight(0xcceeff, 0x222233, 0.7);
  scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 0.9);
  dir.position.set(10,30,20);
  dir.castShadow = true;
  dir.shadow.mapSize.set(1024,1024);
  dir.shadow.camera.left = -50; dir.shadow.camera.right = 50; dir.shadow.camera.top = 50; dir.shadow.camera.bottom = -50;
  scene.add(dir);

  // ---------- Ground / environment ------------------
  const groundMat = new THREE.MeshStandardMaterial({color:0x2a3b50, roughness:1, metalness:0});
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(CONFIG.worldSize.x, CONFIG.worldSize.z, 64,64), groundMat);
  ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; ground.position.y = -0.01;
  scene.add(ground);

  // Procedural grid of obstacles to add interest
  const obstacles = new THREE.Group();
  const obstacleMat = new THREE.MeshStandardMaterial({color:0x1f6fa0});
  for(let i=-12;i<=12;i++){
    for(let j=0;j<24;j++){
      if(Math.random() > 0.7) continue;
      const w = 1 + Math.random()*4; const h = 1 + Math.random()*6; const d = 1 + Math.random()*4;
      const box = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), obstacleMat.clone());
      box.position.set(i*6 + (Math.random()-0.5)*1.5, h/2 - 0.5, -j*24 + (Math.random()-0.5)*6);
      box.castShadow = true; box.receiveShadow = true;
      box.userData.static = true;
      obstacles.add(box);
    }
  }
  scene.add(obstacles);

  // ---------- Sky & fog tweaks ----------------------
  const skyGeo = new THREE.SphereGeometry(800,32,15);
  const skyMat = new THREE.MeshBasicMaterial({color:0x071225, side:THREE.BackSide});
  const sky = new THREE.Mesh(skyGeo, skyMat); scene.add(sky);

  // ---------- Player & controls ---------------------
  const player = {
    pos: new THREE.Vector3(0, CONFIG.player.height, 6),
    vel: new THREE.Vector3(0,0,0),
    speed: CONFIG.player.speed,
    radius: CONFIG.player.radius,
    height: CONFIG.player.height,
    canJump: true,
    health: 100,
    ammo: 30,
    score: 0
  };

  // Camera holder for smoothing
  const cameraHolder = new THREE.Object3D(); cameraHolder.position.copy(player.pos); scene.add(cameraHolder); cameraHolder.add(camera); camera.position.set(0,0,0);

  const controls = new THREE.PointerLockControls(camera, canvas);
  document.getElementById('lockBtn').addEventListener('click', ()=> controls.lock());
  document.addEventListener('click', ()=>{ if(!controls.isLocked) controls.lock(); });
  controls.addEventListener('lock', ()=>{ document.getElementById('menu').style.display='none'; });
  controls.addEventListener('unlock', ()=>{ document.getElementById('menu').style.display='block'; });

  // Input
  const keys = {};
  window.addEventListener('keydown', (e)=>{ keys[e.code]=true; if(e.code==='KeyR') respawn(); if(e.code==='KeyF') toggleFullscreen(); });
  window.addEventListener('keyup', (e)=>{ keys[e.code]=false; });

  // ---------- Weapons & projectiles ----------------
  const bullets = [];
  const MAX_AMMO = 90;
  function fireWeapon(){
    if(player.ammo <= 0) { playSfx('empty'); return; }
    player.ammo--; updateUI(); playSfx('shoot');
    // projectile
    const dirVec = new THREE.Vector3(); camera.getWorldDirection(dirVec);
    const origin = camera.getWorldPosition(new THREE.Vector3());
    const bulletMesh = new THREE.Mesh(new THREE.SphereGeometry(0.08,6,6), new THREE.MeshBasicMaterial({color:0xfff6cc}));
    bulletMesh.position.copy(origin).add(dirVec.clone().multiplyScalar(1.2));
    bulletMesh.userData = { vel: dirVec.clone().multiplyScalar(CONFIG.bulletSpeed), life: 2.4, damage: 34 };
    bulletMesh.castShadow = false; scene.add(bulletMesh); bullets.push(bulletMesh);
  }

  // Simple cooldown & mouse handling
  let canShoot = true; const fireRate = 0.12; let lastShot = 0;
  canvas.addEventListener('mousedown', (e)=>{ if(e.button === 0 && controls.isLocked) { if(canShoot && performance.now()/1000 - lastShot > fireRate) { fireWeapon(); lastShot = performance.now()/1000; } } });

  // ---------- Particle system ----------------------
  const particles = [];
  function spawnParticles(p, color=0xffcc66, n=12){
    for(let i=0;i<n;i++){
      const s = new THREE.Mesh(new THREE.SphereGeometry(Math.random()*0.06+0.02,6,6), new THREE.MeshBasicMaterial({color}));
      s.position.copy(p);
      s.userData = { vel: new THREE.Vector3((Math.random()-0.5)*6, (Math.random()*4)+1, (Math.random()-0.5)*6), life: 0.6 + Math.random()*0.6 };
      s.castShadow=false; scene.add(s); particles.push(s);
    }
  }

  // ---------- Enemies (class) ----------------------
  class Enemy {
    constructor(position){
      const geo = new THREE.CapsuleGeometry(0.5,1.0,4,8);
      const mat = new THREE.MeshStandardMaterial({color:0xff7a7a});
      this.mesh = new THREE.Mesh(geo, mat); this.mesh.position.copy(position); this.mesh.castShadow=true; this.mesh.userData.health = 70 + Math.floor(Math.random()*40);
      this.state = 'patrol'; this.speed = 1.2 + Math.random()*1.4; this._lastAttack = 0; scene.add(this.mesh);
    }
    update(dt){
      const toPlayer = player.pos.clone().sub(this.mesh.position); const dist = toPlayer.length();
      if(dist < 2.0){ // attack
        if(performance.now()/1000 - this._lastAttack > 1.0){ this._lastAttack = performance.now()/1000; player.health -= 10; updateUI(); playSfx('hit'); spawnParticles(this.mesh.position,0xff6666,8); if(player.health <= 0) gameOver(); }
        this.mesh.position.add(toPlayer.normalize().multiplyScalar(this.speed * dt * 0.5));
      } else if(dist < 26){ // chase
        this.mesh.position.add(toPlayer.normalize().multiplyScalar(this.speed * dt));
      } else { // roam/patrol
        this.mesh.position.x += Math.sin(performance.now()/1000 + this.mesh.position.z) * 0.4 * dt;
      }
      // simple gravity on enemy
      if(this.mesh.position.y > 0.5) this.mesh.position.y -= 9.8 * dt;
    }
    takeDamage(dmg){ this.mesh.userData.health -= dmg; playSfx('enemyHurt'); spawnParticles(this.mesh.position,0xffdd88,12); if(this.mesh.userData.health <= 0) { playSfx('enemyDie'); spawnParticles(this.mesh.position,0xff8866,20); scene.remove(this.mesh); return true; } return false; }
  }

  const enemies = [];
  function spawnEnemyAt(x,z){ if(enemies.length > CONFIG.maxEnemies) return; const y = 1.0; const e = new Enemy(new THREE.Vector3(x,y,z)); enemies.push(e); updateUI(); }
  // spawn initial enemies
  for(let i=0;i<CONFIG.enemy.count;i++){ spawnEnemyAt((Math.random()-0.5)*160, -30 - Math.random()*260); }

  // ---------- Pickups ------------------------------
  const pickups = [];
  function spawnPickup(type, pos){ const g = new THREE.IcosahedronGeometry(0.28,0); const m = new THREE.MeshStandardMaterial({color:type==='health'?0x99ff99:0xffea99}); const mesh = new THREE.Mesh(g,m); mesh.position.copy(pos); mesh.userData.type = type; scene.add(mesh); pickups.push(mesh); }
  // rarely spawn pickups
  setInterval(()=>{ if(Math.random() < 0.12) spawnPickup(Math.random() > 0.5 ? 'ammo' : 'health', new THREE.Vector3((Math.random()-0.5)*160,1.2,-40 - Math.random()*500)); }, 1200);

  // ---------- Simple collision helpers -------------
  function pointDistanceToMesh(mesh, point){ const box = new THREE.Box3().setFromObject(mesh); return box.distanceToPoint(point); }

  // ---------- Audio (WebAudio procedural SFX) ------
  const AudioCtx = window.AudioContext || window.webkitAudioContext; const audioCtx = AudioCtx ? new AudioCtx() : null;
  function playSfx(name){ if(!audioCtx || !sfxEnabled) return; const t = audioCtx.currentTime; if(name==='shoot'){ const o = audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type='square'; o.frequency.value=880; g.gain.value=0.02; o.connect(g); g.connect(audioCtx.destination); o.start(t); o.stop(t+0.06); }
    else if(name==='empty'){ const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type='triangle'; o.frequency.value=220; g.gain.value=0.01; o.connect(g); g.connect(audioCtx.destination); o.start(t); o.stop(t+0.12); }
    else if(name==='hit'){ const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type='sawtooth'; o.frequency.value=120; g.gain.value=0.03; o.connect(g); g.connect(audioCtx.destination); o.start(t); o.stop(t+0.06); }
    else if(name==='enemyDie'){ const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type='sine'; o.frequency.value=300; g.gain.value=0.04; o.connect(g); g.connect(audioCtx.destination); o.start(t); o.stop(t+0.22); }
    else if(name==='enemyHurt'){ const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type='square'; o.frequency.value=420; g.gain.value=0.02; o.connect(g); g.connect(audioCtx.destination); o.start(t); o.stop(t+0.08); }
  }
  let sfxEnabled = true; let musicEnabled = true;

  // ---------- Game state & UI ---------------
  let isRunning = false; let lastTime = performance.now()/1000; let highScore = parseInt(localStorage.getItem('israel_highscore')||'0',10);
  document.getElementById('score').innerText = player.score; document.getElementById('health').innerText = player.health; document.getElementById('ammo').innerText = player.ammo; document.getElementById('enemiesCount').innerText = enemies.length; document.getElementById('highScore') && (document.getElementById('highScore').innerText = highScore);

  document.getElementById('startBtn').addEventListener('click', ()=>{ document.getElementById('menu').style.display='none'; controls.lock(); startGame(); });
  document.getElementById('hideMenu').addEventListener('click', ()=>{ document.getElementById('menu').style.display='none'; controls.lock(); startGame(); });
  document.getElementById('pauseBtn').addEventListener('click', ()=>{ isRunning = !isRunning; document.getElementById('pauseBtn').innerText = isRunning ? 'Pause' : 'Resume'; });
  document.getElementById('resetBtn').addEventListener('click', ()=>{ resetWorld(); });
  document.getElementById('musicToggle').addEventListener('change',(e)=>{ musicEnabled = e.target.checked; });
  document.getElementById('sfxToggle').addEventListener('change',(e)=>{ sfxEnabled = e.target.checked; if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); });
  document.getElementById('difficultySelect').addEventListener('change', ()=>{ /* difficulty applied in spawn rates / speeds */ });
  document.getElementById('sensitivity').addEventListener('input', (e)=>{ const s = parseFloat(e.target.value); controls.pointerSpeed = s; });

  function startGame(){ isRunning=true; player.health=100; player.ammo=30; player.score=0; lastTime = performance.now()/1000; document.getElementById('score').innerText=0; document.getElementById('health').innerText=100; document.getElementById('ammo').innerText=player.ammo; }
  function resetWorld(){ // remove enemies, pickups, bullets, particles
    enemies.forEach(e=>{ if(e.mesh) scene.remove(e.mesh); }); enemies.length = 0; bullets.forEach(b=>scene.remove(b)); bullets.length = 0; pickups.forEach(p=>scene.remove(p)); pickups.length=0; particles.forEach(p=>scene.remove(p)); particles.length=0; spawnInitialEnemies(); player.pos.set(0,CONFIG.player.height,10); cameraHolder.position.copy(player.pos); player.health=100; player.ammo=30; updateUI(); }

  function spawnInitialEnemies(){ for(let i=0;i<CONFIG.enemy.count;i++){ spawnEnemyAt((Math.random()-0.5)*160, -30 - Math.random()*260); } }
  spawnInitialEnemies();

  function updateUI(){ document.getElementById('score').innerText = player.score; document.getElementById('health').innerText = Math.max(0,Math.floor(player.health)); document.getElementById('ammo').innerText = player.ammo; document.getElementById('enemiesCount').innerText = enemies.length; }

  function respawn(){ player.health = 100; player.pos.set(0, CONFIG.player.height, 8); cameraHolder.position.copy(player.pos); updateUI(); }
  function toggleFullscreen(){ if(!document.fullscreenElement) document.documentElement.requestFullscreen(); else document.exitFullscreen(); }

  function gameOver(){ isRunning = false; showMenu('Game Over — You died. Press Play to try again.'); if(player.score > highScore){ highScore = player.score; localStorage.setItem('israel_highscore', highScore); } }

  function showMenu(message){ const m = document.getElementById('menu'); m.style.display='block'; m.querySelector('h2').innerText = message; }

  // ---------- Core update loop ----------------------
  function update(){
    const now = performance.now()/1000; const dt = Math.min(now - lastTime, 0.05); lastTime = now; if(!isRunning){ render(); requestAnimationFrame(update); return; }

    // Player movement
    const forward = new THREE.Vector3(); camera.getWorldDirection(forward); forward.y = 0; forward.normalize();
    const right = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), forward).normalize();
    const move = new THREE.Vector3(); if(keys['KeyW']||keys['ArrowUp']) move.add(forward); if(keys['KeyS']||keys['ArrowDown']) move.sub(forward); if(keys['KeyA']||keys['ArrowLeft']) move.add(right); if(keys['KeyD']||keys['ArrowRight']) move.sub(right);
    if(move.lengthSq()>0) move.normalize();
    // speed changes by difficulty
    const difficultyMult = document.getElementById('difficultySelect').value === 'Hard' ? 1.12 : (document.getElementById('difficultySelect').value === 'Easy' ? 0.9 : 1.0);

    player.pos.add(move.multiplyScalar(player.speed * difficultyMult * dt));

    // gravity & jump
    player.vel.y += CONFIG.gravity * dt; player.pos.y += player.vel.y * dt;
    if(player.pos.y < player.height){ player.pos.y = player.height; player.vel.y = 0; player.canJump = true; }
    if((keys['Space'] || keys['KeyK']) && player.canJump){ player.vel.y = CONFIG.player.jumpSpeed; player.canJump = false; }

    // Smooth camera holder follow
    cameraHolder.position.lerp(player.pos, 0.12);

    // Bullets update & collision
    for(let i=bullets.length-1;i>=0;i--){ const b = bullets[i]; b.userData.life -= dt; if(b.userData.life <= 0){ scene.remove(b); bullets.splice(i,1); continue; } b.position.add(b.userData.vel.clone().multiplyScalar(dt));
      // Check enemy collisions
      for(let j=enemies.length-1;j>=0;j--){ const e = enemies[j]; if(e.mesh && e.mesh.position.distanceTo(b.position) < 1.2){ // hit
          const died = e.takeDamage(b.userData.damage); scene.remove(b); bullets.splice(i,1); if(died){ enemies.splice(j,1); player.score += 10; updateUI(); } break; } }
    }

    // Update enemies
    for(let i=enemies.length-1;i>=0;i--){ enemies[i].update(dt); }

    // Update pickups
    for(let i=pickups.length-1;i>=0;i--){ const p = pickups[i]; p.rotation.y += dt*1.2; if(p.position.distanceTo(player.pos) < 1.4){ if(p.userData.type === 'health'){ player.health = Math.min(100, player.health + 34); playSfx('hit'); } else { player.ammo = Math.min(MAX_AMMO, player.ammo + 20); playSfx('shoot'); } scene.remove(p); pickups.splice(i,1); updateUI(); } }

    // Update particles
    for(let i=particles.length-1;i>=0;i--){ const p = particles[i]; p.userData.life -= dt; if(p.userData.life <= 0){ scene.remove(p); particles.splice(i,1); continue; } p.position.add(p.userData.vel.clone().multiplyScalar(dt)); p.userData.vel.y -= 9.8*dt; }

    // Occasional enemy spawns to keep the game lively
    if(Math.random() < 0.006 * difficultyMult){ spawnEnemyAt((Math.random()-0.5)*160, -40 - Math.random()*460); }

    // Update UI
    updateUI();

    render(); requestAnimationFrame(update);
  }

  function render(){ // optional postprocess
    // subtle camera bobbing
    const t = performance.now()/1000;
    camera.rotation.z = Math.sin(t*1.4)*0.002;
    if(composer) composer.render(); else renderer.render(scene, camera);
  }

  // Kick off
  requestAnimationFrame(update);

  // ---------- Utility & debug ------------------------
  function spawnDebugText(text, pos){ if(!CONFIG.debug) return; const div = document.createElement('div'); div.style.position='absolute'; div.style.left='10px'; div.style.top='10px'; div.innerText=text; document.body.appendChild(div); }

  function toggleDebug(){ CONFIG.debug = !CONFIG.debug; }

  // ---------- Helpers for spawnEnemyAt --------------
  function spawnEnemyAt(x,z){ const y = 1.2; spawnEnemyAtInternal(x,z,y); }
  function spawnEnemyAtInternal(x,z,y){ const e = new Enemy(new THREE.Vector3(x,y,z)); enemies.push(e); }

  // ---------- High-level helpers --------------------
  function playMusic(){ if(!audioCtx || !musicEnabled) return; // simple background tone
    const o = audioCtx.createOscillator(); o.type='sine'; o.frequency.value = 110; const g = audioCtx.createGain(); g.gain.value = 0.02; o.connect(g); g.connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime + 3); }

  // ---------- Keyboard shortcuts --------------------
  window.addEventListener('keydown', (e)=>{ if(e.code === 'KeyP') isRunning = !isRunning; if(e.code==='KeyG') toggleDebug(); });

  // Clean up audio on unload
  window.addEventListener('beforeunload', ()=>{ if(audioCtx && audioCtx.state !== 'closed') audioCtx.close(); });

  // ---------- Final notes ---------------------------
  // This file is intentionally structured with clear sections and comments.
  // To make this even better you can:
  // - Replace procedural geometry with GLTF models and textures (use a CDN or host locally)
  // - Add a true physics engine (Cannon.js / Ammo.js) for realistic collisions
  // - Improve AI with pathfinding (navmesh) or steering behaviors
  // - Add music tracks and ambient audio, plus audio mixer for SFX/voice lines

  </script>
</body>
</html>
